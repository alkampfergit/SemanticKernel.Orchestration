using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using SemanticKernel.Orchestration.Assistants.BaseAssistants;
using SemanticKernel.Orchestration.Helpers;
using SemanticKernel.Orchestration.Orchestrators;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace SemanticKernel.Orchestration.Assistants;

public class AssistantBasedOrchestrator : IConversationOrchestrator
{
    private const string DefaultModelName = "gpt4omini";
    private readonly KernelStore _kernelStore;
    private readonly List<BaseAssistant> _assistants;
    private readonly List<(BaseAssistant Assistant, AssistantResponse Response)> _responses = new();

    public AssistantBasedOrchestrator(KernelStore kernelStore)
    {
        _kernelStore = kernelStore;
        _assistants = new List<BaseAssistant>();
        //Add some default assistants
        AddAssistant(new AnswerAssistant(_assistants));
    }

    /// <summary>
    /// Properties are information that are retrieved/generated by agents and can be used 
    /// by other agents or from the base orchestrator to make decisions.
    /// </summary>
    private readonly Dictionary<string, string> _properties = new(StringComparer.OrdinalIgnoreCase);

    public AssistantBasedOrchestrator AddAssistant(BaseAssistant assistant)
    {
        _assistants.Add(assistant);
        assistant.SetOrchestrator(this);
        return this;
    }

    [Description("Get the value of a property to answer user question and finish!")]
    public string? GetProperty([Description("Property name")] string propertyName)
    {
        if (_properties.TryGetValue(propertyName, out var value))
        {
            return value;
        }
        return null;
    }

    /// <summary>
    /// Add a simple property to the current conversation.
    /// </summary>
    /// <param name="propertyName"></param>
    /// <param name="value"></param>
    public void AddProperty(string propertyName, string value)
    {
        _properties[propertyName] = value;
    }

    public BaseAssistant GetAssistant(string name)
    {
        return _assistants.FirstOrDefault(a => a.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
            ?? throw new Exception($"Assistant with name {name} not found");
    }

    public async Task<string> AskAsync(string question, CancellationToken cancellationToken = default)
    {
        var tokenCounter = _kernelStore.GetInterceptor<TokenUsageCounter>();
        var usagePrinter = new TokenUsagePrinter(tokenCounter, new Dictionary<string, (decimal, decimal)>
        {
            { "gpt-4o", (2.39924m/1_000_000, 9.5970m/1_000_000) },           // GPT-4o
            { "gpt-4o-mini", (00.14396m/1_000_000, 0.5759m/1_000_000) }         // GPT-4o Mini
        });
        while (true)
        {
            var kernel = _kernelStore.GetKernel(DefaultModelName);

            //ok I need to get all the functions for all the assistants
            List<KernelFunction> functions = new();
            Dictionary<string, BaseAssistant> assistantMap = new();
            HashSet<string> finalFunctions = new(StringComparer.OrdinalIgnoreCase);

            foreach (var assistant in _assistants)
            {
                foreach (var function in assistant.GetFunctions())
                {
                    functions.Add(function.KernelFunction);
                    assistantMap[function.KernelFunction.Name] = assistant;

                    if (function.IsFinal)
                    {
                        finalFunctions.Add(function.KernelFunction.Name);
                    }
                }
            }

            //add get property to the list

            var settings = new OpenAIPromptExecutionSettings
            {
                FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(functions, autoInvoke: false),
                Temperature = 0,
            };

            //var settings = new PromptExecutionSettings
            //{
            //    FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(functions, autoInvoke: false)
            //};

            //ChatMessageContent result = await PerformCallWithChatModel(question, kernel, settings, cancellationToken);
            ChatMessageContent result = await PerformCallWithSimplePromptModel(question, kernel, settings, cancellationToken);

            //print token usage
            var report = usagePrinter.GetUsageReport();
            Console.WriteLine(report);
            
            var response = result.Items.OfType<FunctionCallContent>().SingleOrDefault();
            if (response == null)
            {
                return result.ToString();
            }

            var assistantToCall = assistantMap[response.FunctionName];
            var assistantFunctionCallResult = await assistantToCall.ExecuteFunctionAsync(response.FunctionName, response.Arguments);
            _responses.Add((assistantToCall, assistantFunctionCallResult));
            if (finalFunctions.Contains(response.FunctionName))
            {
                return assistantFunctionCallResult.Result;
            }

            if (assistantFunctionCallResult.TerminateCycle)
            {
                return assistantFunctionCallResult.State is string s ? s : assistantFunctionCallResult.Result;
            }
        }
    }

    private async Task<ChatMessageContent> PerformCallWithSimplePromptModel(string question, Kernel kernel, PromptExecutionSettings settings, CancellationToken cancellationToken)
    {
        StringBuilder prompt = new();
        prompt.AppendLine(
            @"You are an assistant that should answer user question. 
Analyze FACTS before deciding what to do next.
If FACTS alone can answer the question proceed generating an answer.
If Answer is in one of the property use appropriate tool.
If FACTS are not enough to answer, analyze FACTS to determine what tool call next.");

        foreach (var assistant in _assistants)
        {
            if (!string.IsNullOrEmpty(assistant.InjectedPrompt))
            {
                prompt.AppendLine(assistant.InjectedPrompt);
            }
        }

        prompt.AppendLine("FACTS:");

        foreach (var response in _responses)
        {
            prompt.AppendLine("FACT: " + response.Assistant.GetFact(response.Response));
        }

        prompt.AppendLine("\nUser Question: " + question);

        var functionResult = await kernel.InvokePromptAsync(prompt.ToString(), new(settings), cancellationToken: cancellationToken);
        var content = functionResult.GetValue<ChatMessageContent>()!;
        return content;
    }

    private async Task<ChatMessageContent> PerformCallWithChatModel(string question, Kernel kernel, PromptExecutionSettings settings, CancellationToken cancellationToken)
    {
        ChatHistory chatMessages = new();
        chatMessages.AddSystemMessage(
            @"You are an assistant that should answer user question. Analyze facts before deciding what to do next.
If current state can answer user question proceed generating an answer, if not enough information is present, analyze the state to 
determine what tool call next

FACTS FOLLOW");

        foreach (var response in _responses)
        {
            response.Assistant.AddResultToPrompt(chatMessages, response.Response);
        }

        chatMessages.AddUserMessage("User Question: " + question);

        var chatEngine = kernel.GetRequiredService<IChatCompletionService>();
        var result = await chatEngine.GetChatMessageContentAsync(
            chatMessages,
            settings,
            cancellationToken: cancellationToken);
        return result;
    }
}

public interface IConversationOrchestrator
{
    void AddProperty(string propertyName, string value);
    string? GetProperty([Description("Property name")] string propertyName);
}